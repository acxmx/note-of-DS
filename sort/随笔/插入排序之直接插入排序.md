# 插入排序之直接插入排序

插入排序的基本思路就是将所有元素划分为两个区间：**有序区**和**无序区**，开始时有序区只有一个元素，然后依次将无序区的元素一个一个地插入到有序区当中，这种方法称为**增量法**，每插入一个元素称为**一趟**插入。

## 直接插入排序的基本思路

从后向前在有序区中顺序查找插入位置，边查找边移动，当找到第一个小于插入元素的元素，就在它后面插入。



## 算法

```cpp
void insert_sort(RecType R[], int n)
{
    int i, j;
    RecType tmp;
    for (i=1; i<n; i++)
        if (R[i].key < R[i-1].key)
        {
            tmp = R[j];
            j = i-1;
            do
            {
                R[j+1] = R[j];
                j--;
            }while (j >= 0 && tmp.key < R[j].key);
        	R[j+1] = tmp;
        }
}
```



## 分析

### 	时间复杂度

- 最好时间复杂度：初始数据序列为正序，此时算法只考虑比较次数

  无序区中所有元素仅需进行一次比较，无需移动，所以时间复杂度为

$$
O(n)
$$

- 最坏时间复杂度：初始数据序列为反序，此时比较次数以及移动次数均达到最大。

  第i个元素的插入到有序区[0, i-1]需要比较 i次比较；每次比较后都需要移动，加上两次额外操作，需要i+2次移动，所以时间复杂度为
  $$
  \sum _1^{n-1} (C_i+M_i) = \sum _1^{n-1}(i + (i+2)) = O(n^2)
  $$

- 平均时间复杂度：第i个元素插入到有序区平均需要比较i/2次，平均需要移动次数i/2+2次，所以平均时间复杂度为
  $$
  \sum _1^{n-1} (\frac i2 + (\frac i2+2) ) = O(n^2)
  $$

  ### 空间复杂度

  算法使用的临时变量与问题规模无关，所以时间复杂度为
  $$
  O(1)
  $$

  ### 稳定性

  元素插入到第一个小于等于它的元素后面，关键字相同的元素之间的相对位置不变，因此算法稳定

  ### 适用情况

  数据量较少，且数据序列基本有序的情况