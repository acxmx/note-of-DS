# 选择排序之简单选择排序

## 思路

每趟从无序区里选一个最小的元素放到有序区的后面

-----

简单选择的思路：

```c++
//在区间i~n之间选择最小元素
int min(int a[], int n, int i)
{
    int k = i, j;
    for (j=i+1; j<n; j++)
        if (a[j] < a[k]) k = j;
    return a[k];
}
```



## 实现

```c++
void select_sort(RecType R[], int n)
{
    int i, j, k;
    for (i=0; i<n-1; i++)
    {
        k = i;
        for (j=i+1; j<n; j++)
            if (R[j].key < R[k].key) k = j;
        if (k != i)
            swap(R, k, i);
    }
}
```



## 算法分析

### 时间复杂度

无论元素表是正序的还是反序的，算法都固定需要执行n-1趟选择，每趟选择进行(n-i-1)次比较，元素的移动次数只与选择的趟数有关，所以，最好、最坏和平均时间复杂度都为
$$
O(n^2)
$$


### 空间复杂度

算法的临时变量规模与问题规模无关，所以空间复杂度为
$$
O(1)
$$


### 稳定性

不稳定