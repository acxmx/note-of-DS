# 树和二叉树

从逻辑结构的角度看，树形结构是一大类的数据结构，是一个广泛的概念。而两种典型的树形结构就是树和二叉树。



## 树

##### 基本概念

形式定义：

树的定义也可以采用形式化的定义 --> 用二元组表示 --> 因为二元组是一种通用的表示方法

递归定义：

**树是由n（n >= 0）个结点组成的有限集合。**

**1.当n=0时，这是一棵空树**

**2.当n>0时，集合中有且仅有一个结点作为根结点，其余m个结点分为若干个互不相交的有限子集，作为根结点的子树，每棵子树都是一棵符合本定义的数**

树的定义是递归的！这是树的固有特性！

树常用于表示具有层次关系的数据！



逻辑角度看，树是一种树形结构，那么它的元素必然存在一对多的关系，

这体现在结点与其后继结点之间的关系 --> 每个结点都有0或多个后继结点。



树形结构的表示方法（常用的两种）：

树形表示法：直观形象，便于理解，但不能用计算机程序画出

括号表示法：相对不直观，但体现树的递归性，并且可以用计算机程序画出



基本运算：

分为3类：

​	查找

​	插入或删除

​	遍历：按照某种方式访问树中所有结点并且每个结点仅访问一次             <--  最基本运算  --> 所有运算都基于此





----

##### 树的基本术语

结点的度、树的度：结点的度即结点的子树个数，树的度即为结点的度的最大值 --> 度为m 的树也称为m次树或m叉树

结点的层数、树的高度：以根结点作为第1层，根结点的后继结点所在层次作为第2层，后续层次以此类推往下递增，数的高度即结点的层次的最大值

分支结点、叶子结点：分支结点即度不为零的结点，叶子结点则是度为零的结点 --> 度为m 的结点称为m分支结点

路径、路径长度：一般来说如无特殊说明，路径就是从高层次结点到低层次结点所经过的结点的序列，这条路径的长度是序列的结点数-1，也等于路径上的分支数。但在算法设计中，常常会涉及低层次结点到高层次结点的路径等的逆路径，因此路径的概念要根据实际应用场景分辨

双亲、孩子、兄弟（堂兄弟）结点：分别对应  -->  前驱、后继、具有同一双亲结点、具有同一层次的结点。

子孙、祖先结点：对应 --> 某个结点的所有子树的所有结点；某个结点到根结点的逆路径上的结点（除结点自身）

树的有序性：如果一棵树的结点按照一定次序从左往右安排，并且结点之间的相对次序不能随意改变，则称这棵树为有序树，否则则是无序树。一棵树默认为有序树。

森林：n（n>0）个互不相交的树的集合称为森林。  森林的生成  --> 把一棵含有子树的树删除根结点，就得到对应的森林；相应的，将n（n>0）棵树加上一个共同的根结点，则得到对应的森林。

----

##### 树的基本性质

树中所有结点数等于所有结点度数之和加1   -- > >     由树的形态推出 --> >   结点与前驱——分支的关系

m次树的第i层的最大结点数为
$$
m^{i-1}(i>=1)
$$
树高为h的m次数的最大结点数为
$$
\frac {m^h-1}{m-1}
$$
n个结点的m次树的最小高度为
$$
\lceil log_m(n(m-1)+1) \rceil
$$

----

##### 树的遍历

先根遍历：如果树非空，则先访问树的根结点，然后从左到右对根结点的子树进行先根遍历

遍历所得序列的第一个元素是根结点的元素值

后根遍历：如果树非空，则先从左到右对根结点的子树进行后根遍历，然后访问根结点

遍历序列的最后一个元素是根结点元素

层序遍历：从上往下，从左到右访问树中的每一个结点



----



## 二叉树

##### 基本概念

**二叉树的定义：**

**二叉树是一个有限的结点集合。**

**这个集合或者为空；或者由一个根结点和两棵互不相交的左右子树的二叉树组成。**



从定义出发，二叉树有5种基本形态：空树、只含根结点、含根结点和左子树、含根结点和右子树、含根结点和左右子树



二叉树与2次数的区别！  -->   明确区分树与二叉树是两种形态不同的树形结构，两者之间不存在包含关系！

区别1：二叉树可以为空，2次数则至少有3个结点（根据树的定义，一个作为根，两个作为根的后继 --> 根为双根分支结点  --> 度为2）

区别2：二叉树严格区分左、右子树，而2次树无要求。



对二叉树进行层序编号：约定编号从树根为1开始，按照从上往下，从左到右的顺序，按照递增的方式，依次对结点进行编号

----

##### 两种特殊的二叉树

满二叉树

**一棵满足如下性质的二叉树：**

**所有分支结点都是双分支结点，并且叶子结点都集中在最下面一层**



或者定义为：给定高度h，一棵满二叉树满足结点数为
$$
2^h-1
$$

特点：只有度为0和2的结点，且叶子结点都即在最下面一层



完全二叉树

**一棵满足如下性质的二叉树：**

**只有最下面两层的结点的度数可以小于2，并且最下面一层的叶子结点都靠左排列**

显著特点：如果有单分支结点，那么这个结点只有左孩子；除了最下面一层，其他层都是满的

----

##### 二叉树的性质

性质1：非空二叉树的叶子结点数等于双分支结点数加1

性质2：由树的性质2推出

性质3：由树的性质3推出

性质4：完全二叉树的特性

性质5：有n(n>0)个结点的完全二叉树高为：
$$
\lceil log_2(n+1) \rceil 或者\lfloor log_2n \rfloor+1
$$



----

二叉树与树、森林的转换  -->  本质是结点关系的转换

树-->二叉树：

第一步：对于作为根结点的结点：左孩子关系  -->  长子关系

第二步：对于作为左孩子结点的结点：兄弟关系  -->  右孩子关系



二叉树还原成树，实际上是转换了结点之间的关系：

结点的左孩子关系转换成长子关系；

将右孩子关系转换为兄弟关系

-----

##### 二叉树的存储结构

###### 1.

顺序存储结构

用一组连续的内存单元存放二叉树的数据元素，而因为进行了层序编号的二叉树中的每个结点都对应一个编号，而完全二叉树的结点之间的关系可以根据结点编号进行反映，所以对于给定的一棵二叉树，可以将其补全为一棵完全二叉树，然后将结点存储到对应下标的内存位置。

因为顺序存储结构具有随机存取的特点，所以能够快速地访问树中的任意结点。不足也就是顺序存储结构的固有缺陷——使用不当会造成内存空间的浪费。  -->>   存储空间与树的形态有关

比如：用顺序存储结构存储一棵右单支二叉树，假设它有n个结点，也就是它的高度为n，因为要用顺序存储结构，所以要将它补全为完全二叉树，而根据二叉树的性质，这棵右单支数对应的是一棵满二叉树，即有$2^n-1$个结点，当n很大的时候，存储空间的浪费将是指数级别的。

综上所述，对于二叉树，顺序存储结构比较适用于存储完全二叉树

###### 2.

二叉链存储结构

弥补了顺序存储结构的不足，节省存储空间 -->>  因为存储结构与树的形态无关

假设用二叉链存储的二叉树有n个结点，则可以推出：有2n个指针域，其中n-1个指针域指向了某个结点（存储结构中的指针域实际对应逻辑结构中的分支），n+1个空指针域。

类型声明：

```c
typedef struct node
{
    ElemType data;
    struct node *lchild;
    struct node *rchild;
}BTNode;
```



----

二叉树的基本运算

数据结构的抽象数据类型 = 逻辑结构 + 基本运算   -->>   对应存储结构中的类型声明、函数声明

1.

创建

即将逻辑结构上的二叉树映射到存储结构上，假设采用的逻辑结构的表示方法为括号表示法，这样就可以很容易地将二叉树存储到计算机中。

其原因有：括号表示法可以用字符串来处理；括号表示法体现了树的递归性——用括号表示根结点与子树的关系；括号是遵守就近匹配原则的，所以创建过程可以用栈来描述；可以将括号表示法的字符分类，进而根据字符的类别区分处理情况。

```c
void create_btree(BTNode **pp, char *str)
{
    int len = strlen(str);
    int k, i = 0, top = -1;
    char ch;
    BTNode *p, *stack[len];
    init_btree(pp);
    ch = *(str + i);
    while (ch != '\0')
    {
        switch (ch)
        {
            case '(':
              stack[++top] = p;
              k = 1;
              break;
            case ',':
              k = 2;
              break;
            case ')':
              top--;
              break;
            default:
                p = (BTNode *)malloc(sizeof(BTNode));
                p->data = ch;
                p->lchild = p->rchild = NULL;
                if (*pp == NULL)
                    *pp = p;
                else
                {
                    switch (k)
                	{
                    case 1:
                        stack[top]->lchild = p;
                        break;
                    case 2:
                        stack[top]->rchild = p;
                        break;
                	}
                }
                break;
        }
        i++;
        ch = *(str + i);
    }
}
```

2.

销毁，基于递归实现，首先明确二叉树是递归的数据结构，所以很多问题可以采用递归思想解决！

思路：

1 把销毁一棵二叉树看成是一个大问题

2 分解出小问题：销毁当前这棵二叉树的左右子树

3 假设小问题可解，解决大问题——销毁根结点

4 寻找特殊情况——递归出口——当二叉树为空，停止销毁

```c
void destroy_btree(BTNode *bt)
{
    if (bt == NULL)
        return ;
    else
    {
        destroy_btree(bt->lchild);
        destroy_btree(bt->rchild);
        free(bt);
    }
}
```

3.

输出二叉树的括号表示法，本质是遍历一棵二叉树，很显然可以用递归的方法

```c
void print_btree(BTNode *bt)
{
    if (bt != NULL)
    {
        printf("%c", p->data);
        if (bt->lchild != NULL || bt->rchild != NULL)
        {
            printf("(");
            print_btree(bt->lchild);
            if (bt->rchild != NULL)
                printf(",");
            print_btree(bt->rchild);
            printf(")");
        }
    }
}
```

---

##### 二叉树的遍历

先序遍历

中序遍历

后序遍历

层序遍历：如果树非空，一层一层地从左往右访问每层的所有结点，第一个访问的结点显然是根结点。

-----

##### 二叉树的递归算法

递归是二叉树这种数据结构的固有特性，因此与二叉树相关的算法往往需要用递归思想来解决，如果算法与二叉树的遍历相关，更是如此。（以下算法均假设二叉树的存储结构为二叉链）



3.

查找结点值为x的结点所在的层次，考虑的是结点唯一的情况

```c
int find_node_level(BTNode *bt, ElemType x, int h)
{
    if (bt == NULL)
        return 0;
    else if (bt->data == x)
        return h;
    else
    {
        int l = find_node_level(bt->lchild, x, h+1);
        if (l != 0)
            return l;
        else
            return find_node_level(bt->rchild, x, h+1);
    }
}
```

思路：结点查找  -->>   遍历二叉树；要判断当前所在层次，利用函数参数和返回值传递信息的作用实现。





4.

统计第k层的结点个数

```CQL
//全局变量版
int cnt = 0;
void count_node_k(BTNode *bt, int k, int h)
{
    if (bt == NULL)
        return ;
    else if (h == k)
        cnt++;
    else if (h < k)
    {
        count_node_k(bt->lchild, k, h+1);
        count_node_k(bt->rchild, k, h+1);
    }
}
```



```c
//指针版
void count_node_k(BTNode *bt, int k, int h, int *p)
{
    if (bt == NULL)
        return ;
    else if (h == k)
        (*p)++;
    else if (h < k)
    {
        count_node_k(bt->lchild, k, h+1, p);
        count_node_k(bt->rchild, k, h+1, p);
    }
}
```

思路：统计给定层的结点个数，显然要涉及到结点的查找，而一般的二叉树的结点查找是基于遍历操作的，所以需要使用递归；要找第k层，那么就利用参数传值的方法记录当前的层次；统计个数，显然需要计数器，方法有2。

其一：因为算法是递归的，要保证参数的同一性，可以使用全局变量。

其二：因为算法是递归的，而递归调用实际上是用程序栈实现的，所以可以将主调函数中的局部变量看成相对于递归调用函数是全局的，所以可以在主调函数中定义局部变量充当计数器，然后用指针类型传递给递归调用函数。



5.

输出结点值为x 的结点的所有祖先





-----

##### 二叉树的非递归遍历

###### 先序遍历

回顾定义 ： 如果二叉树不为空，则访问根结点，然后先序遍历左子树，再先序遍历右子树。

递归出口是二叉树为空

解法1：递归到栈实现的转换

细化先序遍历一棵二叉树的过程：访问根结点  -->> 如果左子树不空，访问左子树的根结点 （相当于递归遍历中的递归体——先序遍历左子树） -->>   如果左子树的左子树不为空，访问左子树的左子树的根结点  -->>   ……  -->>   直到某棵左子树的左子树为空（相当于递归遍历中的递归出口），这时可以当做是这棵左子树的左子树已被访问过，进而转向访问它的右子树；对右子树重复前面的操作，直到某棵子树的右子树为空，这时可以当做这棵子树的右子树已被访问过，这意味着这一整棵子树都被访问过，所以转向访问这棵子树的根结点的右子树，如果这棵子树的根结点的右子树为空，或者当前这棵子树就是其根结点的右子树，则以这棵子树的根结点作为根结点的二叉树就访问完毕。

```c
void pre_travel(BTNode *bt)
{
    
}
```

解法2：栈的常规做法



###### 中序遍历

