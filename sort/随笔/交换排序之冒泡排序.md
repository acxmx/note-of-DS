# 交换排序之冒泡排序

## 思路

将元素序列分成有序和无序区。从后往前将元素两两进行比较，如果相对逆序，则交换元素，直到将一个元素合并到有序区的后面。重复以上步骤，直到无序区剩下一个元素。



## 实现

```c++
void bubble_sort(RecType R[], int n)
{
    int i, j;
    bool exchange;
    for (i=0; i<n-1; i++)
    {
        exchange = false;
        for (j=n-1; j>i; j--)
            if (R[j].key < R[j-1].key)
                swap(R,j,j-1);
        if (!exchange)
            return ;
    }
}
```

### 

## 算法分析

### 时间复杂度

- 最好时间复杂度：元素序列正序，此时比较n-1次就退出，所以为
  $$
  O(n)
  $$

- 最坏时间复杂度：元素逆序，此时每趟比较(n-i-1)次，每次比较交换一次 --> 即移动元素3次，所以时间复杂度为
  $$
  \sum _0^{n-2} (C_i + M_i) = \sum _0^{n-2} ((n-i-1) + 3(n-i-1)) = O(n^2)
  $$

- 平均时间复杂度：平均情况的分析比较复杂，因为算法可能在中间某一到排序完成后就终止了，但是可以认为平均会进行（n-i-1）/2趟排序，所以平均情况的时间复杂度还是
  $$
  O(n^2)
  $$



### 空间复杂度

临时变量与问题规模n无关，所以
$$
O(1)
$$

### 稳定性

元素逆序时才进行交换，关键字相同元素之间不进行交换，相对次序不变，所以算法稳定；另外算法的有序区是全局有序区，因为每趟冒出来的元素都是合并到有序区的后面。