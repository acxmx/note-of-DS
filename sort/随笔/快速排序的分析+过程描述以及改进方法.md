# 快速排序的分析+过程描述以及改进方法

快速排序的基本思想是通过一趟排序将原表划分成两个子表，其一一个子表的元素比另一个子表的都要小，然后再对两个子表进行快速排序，直到表中元素有序排列。

##### 算法分析与过程描述

从定义可以看出，快速排序的过程是递归的，因此，其排序过程可以描述成对应的一棵递归树。以下分析假设待排序的表有n个元素。

当元素基本无序的时候，每一趟划分都将原表划分成两个表，并且归位一个元素，这时划分过程可以近似看成一棵完全二叉树，所以树高为$O(log_2n)$；而每一趟划分都会进行与待排序元素个数次减1次比较，归根结底，每趟排序的时间复杂度与问题规模n有关，所以每一趟排序的时间复杂度为$O(n)$。所以时间复杂度为$O(nlog_2n)$，这是平均时间复杂度，符合基于比较的排序算法的最好时间复杂度。

当元素基本正序或者反序时，划分过程就蜕化成一棵单支树，树高为$O(n)$，而每一趟排序的时间复杂度与描述排序过程的树形无关，所以依然是$O(n)$，所以时间复杂度为$O(n^2)$，这是最坏时间复杂度。



##### 改进方法

基准选择方法

选择表中中间位置元素

三数中值

随机数下标



针对正序或反序的情况，选择选择表中中间位置元素的方法。

```c
void quick_sort(int *arr, int s, int t)
{
    if (s < t)
    {
        int i, mid = (s + t) / 2;
        swap(arr, s, mid);
        i = partition(arr, s, t);
        quick_sort(arr, s, i-1);
        quick_sort(arr, i+1, t);
    }
}
```



基本的快速排序是将比较得到两个元素进行交换，而元素的两两交换需要进行3次移动，其实可以利用辅助存储空间的方法，将基准先用变量存储，这个时候元素表在排序过程中就一直会有一个空位置，实现两个元素交换所需的移动次数就变成了2，这是一种空间换时间的方法。

```c
int partition(int *arr, int low, int high)
{
    int i = low, j = high;
    int pivot = *(arr+low);
    while (i < j)
    {
        while (j > i && *(arr+j) >= pivot)
            j--;
        *(arr+i) = *(arr+j);
        while (i < j && *(arr+i) <= pivot)
            i++;
        *(arr+j) = *(arr+i);
    }
    *(arr+i) = pivot;
    return i;
}
```

